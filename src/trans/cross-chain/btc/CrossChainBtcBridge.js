'use strict'

const bitcoin = require('bitcoinjs-lib');

let utils                   = require('../../../util/util');
let ccUtil                  = require('../../../api/ccUtil');
let BtcTransaction          = require('../../transaction/btc/BtcTransaction');
let BtcDataSign             = require('../../data-sign/btc/BtcDataSign');
let BridgeTxBtcDataCreator    = require('../../tx-data-creator/btc/BridgeTxBtcDataCreator');
let CrossChain              = require('../common/CrossChain');

const logger = utils.getLogger("CrossChainBtcBridge.js");

class CrossChainBtcBridge extends CrossChain {
    /**
     * @param: {Object} - input
     *    For BTC:
     *    {
     *        from:       - array, from address to lock
     *        tokenPairID:- tokenPairID
     *        value       - amount to send in storeman
     *        feeRate     -
     *        changeAddress  - address to send if there's any change
     *        storeman    - BTC storeman address
     *        to          -
     *            path
     *            walletID
     *        op_return   - tokenPairId + changeAddress
     *    }
     */
    constructor(input,config) {
        super(input,config);
        this.input.chainType = config.srcChainType;
    }

    createTrans(){
        logger.debug("Entering CrossChainBtcBridge::createTrans");
        this.retResult.code = true;
        if (this.input.chainType == 'BTC') {
            this.retResult.result = new BtcTransaction(this.input, this.config);
        } else {
            logger.error("Chain type invalid: ", this.input.chainType);
            this.retResult.code   = false;
            this.retResult.result = "ChainType error.";
        }
        logger.debug("CrossChainBtcBridge::createTrans is completed");
        return this.retResult;
    }

    createDataCreator(){
        logger.debug("Entering CrossChainBtcBridge::createDataCreator");
        this.retResult.code = true;
        if (this.input.chainType == 'BTC') {
            this.retResult.result = new BridgeTxBtcDataCreator(this.input,this.config);
        } else {
            logger.error("Chain type invalid: ", this.input.chainType);
            this.retResult.code   = false;
            this.retResult.result = "ChainType error.";
        }
        logger.debug("CrossChainBtcBridge::createDataCreator is completed");
        return this.retResult;
    }

    createDataSign(){
        logger.debug("Entering CrossChainBtcBridge::createDataSign");
        this.retResult.code = true;
        if (this.input.chainType == 'BTC') {
            this.retResult.result = new BtcDataSign(this.input,this.config);
        } else {
            logger.error("Chain type invalid: ", this.input.chainType);
            this.retResult.code   = false;
            this.retResult.result = "ChainType error.";
        }
        logger.debug("CrossChainBtcBridge::createDataCreator is completed");
        return this.retResult;
    }

    /**
     * @override
     * @returns {{code: boolean, result: null}|transUtil.this.retResult|{code, result}}
     */
    preSendTrans(signedData){
        logger.debug("Entering CrossChainBtcBridge::preSendTrans");
        // TODO:
        let now = Number((Date.now() / 1000).toFixed(0));
        let storeman;
        let from;
        let to;
        let amount;

        storeman = this.input.storeman;
        from = this.trans.commonData.from;
        to = this.input.to;
        // to   = ccUtil.hexTrip0x(this.trans.commonData.to);
        // Amount is the total number to send, value is tx fee,
        // but in BTC SDK it saves amount same as value
        amount = this.trans.commonData.value;

        // TODO: hashX & x are generated by create contract, and passed back to input, may need another way to pass it!!!
        let record = {
          "hashX"                  : ccUtil.hexTrip0x(this.input.hashX),
          "x"                      : ccUtil.hexTrip0x(this.input.x), // TODO: x is set by create contract data
          "from"                   : from,
          "fromAddr"               : this.input.fromAddr,
          "to"                     : to,
          "toAddr"                 : this.input.toAddr,
          "changeAddress"          : this.input.changeAddress,
          "storeman"               : storeman,
          "smgBtcAddr"             : this.input.smgBtcAddr,
          "tokenPairID"            : this.input.tokenPairID,
          "value"                  : ccUtil.weiToToken(this.input.value, this.config.tokenDecimals),
          "contractValue"          : ccUtil.hexAdd0x(this.input.value.toString(16)),
          "crossValue"             : ccUtil.hexAdd0x(this.input.crossValue.toString(16)),
          "networkFee"             : ccUtil.hexAdd0x(this.trans.commonData.networkFee.toString(16)),
          "sendTime"               : parseInt(Number(Date.now())/1000).toString(),
          "htlcTimeOut"            : (2*60*60 + 2 * Number(global.lockedTimeBTC) + now).toString(), // TODO: refactory it
          "buddyLockedTimeOut"     : (Number(global.lockedTimeBTC)+now).toString(),
          "chain"                  : this.input.chainType,
          "status"                 : 'LockSending',
          "approveTxHash"          : "",
          "lockTxHash"             : "",
          "redeemTxHash"           : "",
          "revokeTxHash"           : "",
          "buddyLockTxHash"        : "",
          "lockConfirmed"          : 0,
        //   "refundConfirmed"        : 0,
        //   "revokeConfirmed"        : 0,
        //   "lockTxHash"             : '',
        //   "refundTxHash"           : '',
        //   "revokeTxHash"           : '',
        //   "btcNoticeTxhash"        : '',
        //   "btcLockTxHash"          : '', // this is txhash of BTC HTLC transaction, we can get it after sent
        //   "btcRefundTxHash"        : '',
        //   "btcRevokeTxHash"        : '',
          "tokenSymbol"            :this.config.tokenSymbol,
          "tokenStand"             :this.config.tokenStand,
          "srcChainAddr"           :this.config.srcSCAddrKey,
          "dstChainAddr"           :this.config.dstSCAddrKey,
          "srcChainType"           :this.config.srcChainType,
          "dstChainType"           :this.config.dstChainType,
          "crossMode"              : this.config.crossMode,
          "smgCrossMode"           : this.config.smgCrossMode,
          "crossType"              : this.input.crossType
        };

        logger.debug("CrossChainBtcBridge::preSendTrans");
        logger.debug("collection is :",this.config.crossCollection);
        logger.debug("record is :",ccUtil.hiddenProperties(record,['x']));

        global.wanDb.insertItem(this.config.crossCollection,record);

        this.retResult.code = true;
        logger.debug("CrossChainBtcBridge::preSendTrans is completed");

        return this.retResult;
    }

    postSendTrans(resultSendTrans){
        logger.debug("Entering CrossChainBtcBridge::postSendTrans");
        logger.info("collection is :",this.config.crossCollection);

        let record = global.wanDb.getItem(this.config.crossCollection,{hashX: ccUtil.hexTrip0x(this.input.hashX)});

        if (record) {
            record.status = "LockSent";
            record.lockTxHash = resultSendTrans;

            global.wanDb.updateItem(this.config.crossCollection,{hashX:record.hashX},record);
            this.retResult.code = true;
        } else {
            this.retResult.code = false;
            logger.error("Post send tx, update record not found, hashx=", this.input.hashX);
        }

        logger.debug("CrossChainBtcBridge::postSendTrans is completed");

        return this.retResult;
    }

    /**
     * @override
     */
    transFailed(){
      logger.info("CrossChainBtcBridge::transFailed");
      let record = global.wanDb.getItem(this.config.crossCollection,{hashX: ccUtil.hexTrip0x(this.input.hashX)});
      if (record) {
          record.status = 'sentHashFailed';
          logger.debug("record is :",ccUtil.hiddenProperties(record,['x']));
          global.wanDb.updateItem(this.config.crossCollection,{hashX:record.hashX},record);
      }
      this.retResult.code = true;
      return this.retResult;
    }

    async addNonceHoleToList(){
        if (this.input.chainType == 'BTC') {
            logger.info("addNonceHoleToList, skipped");
        }
    }

    async run(isSend) {
        logger.debug("Entering CrossChainBtcBridge::run");
        //let ret = await CrossChain.prototype.method.call(this);
        let ret = await super.run(isSend);
        if(!isSend) {
            return ret;
        }
        if(ret.code === false){
            logger.error("%s Lock error:", this.input.chainType, ret.result);
            return ret;
        }

        logger.debug("CrossChainBtcBridge::run completed!");

        return ret;
    }
}
module.exports = CrossChainBtcBridge;
  