'use strict'

let  BtcTransaction        = require('../../transaction/btc/BtcTransaction');
let  BtcDataSign           = require('../../data-sign/btc/BtcDataSign');
let  NormalTxBtcDataCreator= require('../../tx-data-creator/btc/NormalTxBtcDataCreator');
let  NormalChain           = require('../common/NormalChain');
let  ccUtil                = require('../../../api/ccUtil');
let  error                 = require('../../../api/error');
let  utils                 = require('../../../util/util');

let logger = utils.getLogger('NormalChainBtc.js');

class NormalChainBtc extends NormalChain{
    /**
     * @param: {Object} -
     *     input {
     *         from:           - array, the from addresses
     *         to:             - target address
     *         value:          - amount to send, in satoshi !!!
     *         feeRate:        -
     *         changeAddress:  - address to send if there's any change
     *     }
     * @param: {Object} -
     *     config {
     *     }
     */
    constructor(input, config) {
        super(input, config);
    }

    /**
     * Same with {@link NormalChain#checkPreCondition NormalChain#checkPreCondition}
     * @returns {{code: boolean, result: null}|transUtil.this.retResult|{code, result}}
     */
    checkPreCondition(){
        logger.debug("Entering NormalChainBtc::checkPreCondition");

        this.retResult.code = false;
        this.retResult.result = new error.InvalidParameter('Invalid parameter');
        if (!this.input.hasOwnProperty('from')){
            logger.error("Input missing attribute 'from'");
            return this.retResult;
        }
        if (!Array.isArray(this.input.from)) {
            logger.error("Invalid input 'from'");
            return this.retResult;
        }
        if (!this.input.hasOwnProperty('to')){
            logger.error("Input missing attribute 'to'");
            return this.retResult;
        }
        if (!this.input.hasOwnProperty('value')){
            logger.error("Input missing attribute 'value'");
            return this.retResult;
        }
        if (!this.input.hasOwnProperty('changeAddress')){
            logger.error("Input missing attribute 'changeAddress'");
            return this.retResult;
        }
        if (!this.input.hasOwnProperty('feeRate')){
            logger.error("Input missing attribute 'feeRate'");
            return this.retResult;
        }

        /* Check if input utxo is enough*/

        this.retResult.result = null;
        this.retResult.code = true;

        logger.debug("NormalChainBtc::checkPreCondition is completed");
        return this.retResult;
    }

    createTrans(){
        logger.debug("Entering NormalChainBtc::createTrans");

        this.retResult.code = true;
        this.retResult.result = new BtcTransaction(this.input, this.config);

        logger.debug("NormalChainBtc::createTrans is completed");
        return this.retResult;
    }

    createDataCreator(){
        logger.debug("Entering NormalChainBtc::createDataCreator");

        this.retResult.code    = true;
        this.retResult.result  = new NormalTxBtcDataCreator(this.input, this.config);

        logger.debug("NormalChainBtc::createDataCreator is completed");
        return this.retResult;
    }

    createDataSign(){
        logger.debug("Entering NormalChainBtc::createDataSign");

        this.retResult.code    = true;
        this.retResult.result  = new BtcDataSign(this.input, this.config);

        logger.debug("NormalChainBtc::createDataSign is completed");
        return this.retResult;
    }

    preSendTrans(signedData){
        logger.debug("Entering NormalChainBtc::preSendTrans");

        let record = {
            "hashX" : this.input.hashX,  // input.hashX is generated by NormalChain
            "from"  : "local btc account",
            "to"    : this.trans.commonData.to,
            "value" : this.trans.commonData.value.toString(10),
            "time"  : Date.now().toString(),
            "txhash": this.input.hashX,
            "chain" : 'BTC',
            "status": "Sending"
        };
        logger.info("NormalChainBtc::preSendTrans");
        logger.info("collection is :",this.config.normalCollection);
        logger.info("record is :",ccUtil.hiddenProperties(record,['x']));
        /**
         * TODO: BTC normal tx doesn't save data in db
         */
        global.wanDb.insertItem(this.config.normalCollection,record);
        this.retResult.code = true;

        logger.debug("NormalChainBtc::preSendTrans is completed");
        return this.retResult;
    }

    /**
     * @override
     */
    transFailed(){
      logger.debug("Entering NormalChainBtc::transFailed");
      logger.debug("collection is :",this.config.normalCollection);

      let hashX  = this.input.hashX;
      let record = global.wanDb.getItem(this.config.normalCollection,{hashX:hashX});

      if (record) {
          record.status = "Failed";

          logger.debug("record is :",ccUtil.hiddenProperties(record,['x']));
          global.wanDb.updateItem(this.config.normalCollection,{hashX:record.hashX},record);

          this.retResult.code = true;
      } else {
          logger.error("Transaction not found: ", hashX);
          this.retResult.data = new error.NotFound("Transaction not found");
          this.retResult.code = false;
      }

      logger.debug("NormalChainBtc::transFailed is completed");
      return this.retResult;
    }

    postSendTrans(resultSendTrans){
        logger.debug("Entering NormalChainBtc::postSendTrans");

        let hashX       = this.input.hashX;
        let record      = global.wanDb.getItem(this.config.normalCollection,{hashX:hashX});

        if (record) {
            /**
             * WARNING: BTC normal tx doesn't save data in db, save sucess directly
             */
            record.status   = 'Success';
            record.txhash   = ccUtil.hexTrip0x(resultSendTrans);

            logger.debug("collection is :",this.config.normalCollection);
            logger.debug("record is :",ccUtil.hiddenProperties(record,['x']));
            global.wanDb.updateItem(this.config.normalCollection,{hashX:record.hashX},record);

            this.retResult.code = true;
        } else {
            logger.error("Transaction not found: ", hashX);
            this.retResult.data = new error.NotFound("Transaction not found");
            this.retResult.code = false;
        }

        logger.debug("NormalChainBtc::postSendTrans is completed");
        return this.retResult;
    }

    async addNonceHoleToList(){
        logger.info("addNonceHoleToList, skipped");
    }
}

module.exports = NormalChainBtc;
